Para proteger tus rutas con middleware en Next.js (Pages Router), vamos a crear un archivo middleware.ts en la ra√≠z del proyecto que:

    Lee la cookie user_info (donde guardamos el JSON del usuario).

    Para rutas protegidas (por ejemplo /dashboard y cualquier ruta bajo /admin), si no existe o es inv√°lida, redirige a /auth/login.

    Para rutas p√∫blicas (home, login, register, assets), no hace nada.

No necesitas ning√∫n otro archivo: el middleware act√∫a antes de renderizar cualquier p√°gina.

Para proteger tus rutas con middleware en Next.js (Pages Router), vamos a crear un archivo `middleware.ts` en la ra√≠z del proyecto que:

1. Lee la cookie `user_info` (donde guardamos el JSON del usuario).
2. Para rutas protegidas (por ejemplo `/dashboard` y cualquier ruta bajo `/admin`), si **no** existe o es inv√°lida, redirige a `/auth/login`.
3. Para rutas p√∫blicas (home, login, register, assets), no hace nada.

No necesitas ning√∫n otro archivo: el middleware act√∫a antes de renderizar cualquier p√°gina.

---

## 1. Crear `middleware.ts`

```ts
// middleware.ts
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

// Rutas que NO requieren autenticaci√≥n
const PUBLIC_PATHS = [
  "/", 
  "/auth/login",
  "/auth/register",
  "/api/auth/logout", 
  "/_next",      // Next.js internals
  "/favicon.ico",
  "/_next/static",
  "/fonts",
  "/images"
];

export function middleware(req: NextRequest) {
  const { pathname } = req.nextUrl;

  // Si es ruta p√∫blica, dejamos pasar
  if (
    PUBLIC_PATHS.some((path) =>
      pathname === path || pathname.startsWith(path)
    )
  ) {
    return NextResponse.next();
  }

  // Intentamos leer la cookie `user_info`
  const userInfo = req.cookies.get("user_info")?.value;

  // Si no existe, redirigimos al login
  if (!userInfo) {
    const loginUrl = new URL("/auth/login", req.url);
    return NextResponse.redirect(loginUrl);
  }

  // Podr√≠as aqu√≠ validar JSON.parse(userInfo) o verificar campos m√≠nimos,
  // pero asumimos que si existe, el middleware de fetch (apiFetch) mantendr√°
  // la sesi√≥n o destruir√° la cookie cuando expire.

  return NextResponse.next();
}

// Aplica middleware a todas las rutas excepto las APIs (opcional)
export const config = {
  matcher: [
    /*
     * Proteger todas las rutas bajo /dashboard y /admin
     * Puedes a√±adir m√°s patrones si lo necesitas.
     */
    "/dashboard/:path*",
    "/admin/:path*",
  ],
};
```

### Explicaci√≥n

* **PUBLIC\_PATHS**: rutas que deben quedar abiertas (home, login, register, assets).
* **matcher** en `config`: especifica a qu√© rutas aplicar la protecci√≥n. Aqu√≠, `/dashboard/*` y `/admin/*`.
* **req.cookies.get("user\_info")**: lee tu cookie `user_info`. Si no existe ‚Üí redirige.

---

## 2. Ajustes adicionales

* Aseg√∫rate de que **tus cookies** se env√≠en con `sameSite: "lax"` y `httpOnly: true` (ya lo tienes).
* Cuando expire o sea inv√°lida, el middleware detecta ausencia de cookie y redirige.
* Tu frontend ya invoca `useAuth()` que por su parte intentar√° silent‚Äìrefresh y, si no puede, redirigir√° al login.

---

## 3. Verificaci√≥n

1. **Coloca** `middleware.ts` en la ra√≠z de tu proyecto Next.js (a la par de `next.config.js`).
2. Arranca el servidor de desarrollo (`npm run dev`).
3. Intenta acceder a `/dashboard` sin estar autenticado ‚Üí **debe** llevarte a `/auth/login`.
4. Despu√©s de hacer login, `/dashboard` debe abrirse con normalidad.

¬°Y con esto tienes tu **protecci√≥n de rutas server‚Äëside** totalmente integrada! üöÄ

    Puedes centralizar las rutas p√∫blicas export√°ndolas desde un solo archivo de configuraci√≥n, para no tener que duplicarlas en middleware, guards, etc.

    Puedes usar patrones en lugar de rutas fijas:

const PUBLIC_PATHS = [
  /^\/$/, 
  /^\/auth\/.*/,
  /^\/api\/auth\/logout$/,
  /^\/_next\/.*/,
  /^\/favicon\.ico$/,
  /^\/fonts\/.*/,
  /^\/images\/.*/
];

    As√≠ reduces el mantenimiento.

    